% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/landscape.r
\name{landscape}
\alias{landscape}
\alias{pl_is_exact}
\alias{pl_str}
\alias{pl_num_levels}
\alias{pl_limits}
\alias{pl_support}
\alias{pl_discretize}
\alias{pl_expand}
\alias{pl_contract}
\title{Persistence Landscapes}
\usage{
landscape(
  pd,
  degree = NULL,
  exact = FALSE,
  xmin = NULL,
  xmax = NULL,
  by = NULL,
  ymin = NULL,
  ymax = NULL
)

pl_is_exact(pl)

pl_str(pl)

pl_num_levels(pl)

pl_limits(pl)

pl_support(pl)

pl_discretize(pl, xmin = NULL, xmax = NULL, by = NULL)

pl_expand(pl, xmin = NULL, xmax = NULL)

pl_contract(pl, xmin = NULL, xmax = NULL)
}
\arguments{
\item{pd}{Persistence data (or diagram), stored as a 2-column matrix or as a
persistence diagram object with element \code{pairs} being a list of 2-column
matrices (birth-death pairs).}

\item{degree}{Non-negative integer; if input is a persistence diagram object,
then the dimension for which to compute a landscape. (For degree $d$, the
$(d+1)$th matrix in the list will be selected.)}

\item{exact}{Set to \code{TRUE} for exact computation, \code{FALSE} (default) for
discrete.}

\item{xmin, xmax}{Domain thresholds for discrete PL; if not specified, then
taken to be the support of the PL constructed from the data or the internal
values of the 'Rcpp_PersistenceLandscape' object.}

\item{by}{Domain grid diameter for discrete PL; if not specified, then set to
the power of 10 that yields between 100 and 1000 intervals.}

\item{ymin, ymax}{Numeric; the threshold used to compute the persistence
diagram or bound to impose on the height of the landscape (default to +/-
1000, could be infinite).}

\item{pl}{A persistence landscape as returned by \code{landscape()}.}
}
\value{
\code{landscape()} returns a persistence landscape (an object of S4 class
'Rcpp_PersistenceLandscape'). Other functions return summary information
about such an object.
}
\description{
Compute persistence landscapes from persistence data.
}
\details{
\code{landscape()} is a wrapper around the S4 class constructor
\verb{[methods:new()]}. The \verb{pl_*()} helper functions take a persistence
landscape as returned by \code{landscape()} and return its representation
(\code{pl_is_exact()} and \code{pl_str()}), the number of levels
(\code{pl_num_levels()}), the endpoints of its internal representation
(excluding infinities) (\code{pl_limits()}), and the endpoints of its support,
i.e. of the points at which its value is nonzero (\code{pl_support()}).
}
\examples{
# sample points
points <- tdaunif::sample_torus_tube(100, 5)

# compute persistence
pd <- as_persistence(ripserr::vietoris_rips(points, dim = 2L, threshold = 1))
print(pd)

# compute persistence landscapes for 0-cycles
pl <- landscape(pd, degree = 1, exact = TRUE)
print(pl)

# first landscape layer
print(pl$getInternal()[[1L]])
# plot all landscape layers
plot(pl)

# coerce to discrete
pl_ <- pl_discretize(pl, xmin = 0, xmax = .5, by = .005)
plot(pl_)
# sample points
points <- tdaunif::sample_torus_tube(60L, 2.5)

# compute persistence data, retaining parameters
pd <- as_persistence(TDA::ripsDiag(points, maxdimension = 2L, maxscale = 3))
print(dim(pd$pairs[[2L]]))

# compute persistence landscape for 1-dimensional cycles
pl <- landscape(pd, degree = 1L, ymax = pd$threshold)
print(pl)

# landscape dimensions
print(dim(pl$getInternal()))
# landscape values
print(pl$getInternal())
# plot landscape
plot(pl)

# custom parameters
pl <- landscape(pd, degree = 1L, by = 0.1, xmax = 2, ymax = pd$threshold)
print(pl)
plot(pl)
}
