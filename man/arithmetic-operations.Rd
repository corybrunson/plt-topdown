% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/operations.r
\name{arithmetic-operations}
\alias{arithmetic-operations}
\alias{pl_sum}
\alias{pl_scale}
\alias{pl_abs}
\alias{pl_mean}
\alias{pl_inner}
\alias{pl_max}
\alias{pl_vmax}
\alias{pl_moment}
\alias{pl_moments}
\alias{pl_distance}
\alias{pl_norm}
\title{Arithmetic Operations on Persistence Landscapes}
\usage{
pl_sum(pl1, pl2)

pl_scale(pl, mult = 1)

pl_abs(pl)

pl_mean(pl_list)

pl_inner(pl1, pl2)

pl_max(pl, level = 1L)

pl_vmax(pl, level = 1L)

pl_moment(pl, p = 1L, center = 0, level = 1L)

pl_moments(pl, p = 1L, center = 0, level = NULL)

pl_distance(pl1, pl2, p = 2)

pl_norm(pl, p = 2)
}
\arguments{
\item{pl, pl1, pl2}{Persistent landscapes.}

\item{mult}{Double; a real-valued scale factor.}

\item{pl_list}{A list of persistent landscapes.}

\item{level}{Positive integer; the envelope of the persistence landscape
(up to) whose moment to calculate.}

\item{p}{Positive integer or infinity; the power used to compute a norm or
moment.}

\item{center}{Double; where to center the moment.}
}
\value{
A persistence landscape (an object of S4 class
'Rcpp_PersistenceLandscape').
}
\description{
Calculate sums, scalar multiples, absolute values, means, inner
products, moments, distances, and norms of persistent landscapes. These
operations arise from the Hilbert space structure on persistence
landscapes ().
}
\examples{
# scale a landscape
x <- tdaunif::sample_torus_tube(4, 2.5)
pd <- as_persistence(ripserr::vietoris_rips(x, dim = 1L, threshold = 2))
pl <- landscape(pd$pairs[[1]], exact = FALSE, max_x=2.5, by=0.1)
print(pl$getInternal()[2, , ])
print(pl$scale(0.5)$getInternal()[2, , ])

# create two landscapes from the same sampling distribution
x <- tdaunif::sample_torus_tube(4, 2.5)
y <- tdaunif::sample_torus_tube(4, 2.5)
x_pd <- as_persistence(ripserr::vietoris_rips(x, dim = 1, threshold = 2))
y_pd <- as_persistence(ripserr::vietoris_rips(y, dim = 1, threshold = 2))
x_pl <- landscape(x_pd$pairs[[1]], exact = FALSE, max_x = 2.5, by = 0.1)
y_pl <- landscape(y_pd$pairs[[1]], exact = FALSE, max_x = 2.5, by = 0.1)

# compare landscapes and calculate mean landscape
print(x_pl$getInternal())
print(y_pl$getInternal())
print(pl_mean(list(x_pl, y_pl))$getInternal())

\dontrun{
set.seed(492869L)

# compute landscape for a large sample
pt <- tdaunif::sample_torus_tube(1000, 5)
pd <- as_persistence(ripserr::vietoris_rips(pt, dim = 2, threshold = 2))
pl <- landscape(pd, degree = 1, exact = FALSE, by = 0.1, min_x = 0, max_x = 2)

# compute landscapes for a large sample of small samples
pl_list <- c()
for (i in seq(100)) {
  pti <- tdaunif::sample_torus_tube(100, 5)
  pdi <- as_persistence(ripserr::vietoris_rips(pti, dim = 2, threshold = 2))
  pli <- landscape(pdi, degree = 1, exact = FALSE, by = 0.1, min_x = 0, max_x = 2)
  pl_list <- c(pl_list, pli)
}

# compute the mean landscape
pl_avg <- pl_mean(pl_list)

# compute the distance between the landscapes
pl_diff <- pl$add(pl_avg$scale(-1))
print(pl_inner(pl_diff, pl_diff))
}
}
\seealso{
PersistenceLandscape-methods
}
